#include "XLang/NativeCodeGen.h"

#include "mlir/Conversion/ArithToLLVM/ArithToLLVM.h"
#include "mlir/Conversion/FuncToLLVM/ConvertFuncToLLVM.h"
#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/Target/LLVMIR/Dialect/Builtin/BuiltinToLLVMIRTranslation.h"
#include "mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h"
#include "mlir/Target/LLVMIR/Export.h"
#include "clang/Driver/Compilation.h"
#include "clang/Driver/Driver.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/TextDiagnosticPrinter.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Support/Errc.h"
#include "llvm/Support/SmallVectorMemoryBuffer.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/TargetParser/Host.h"

llvm::Error xlang::generateNativeBinary(mlir::ModuleOp &module,
                                       llvm::StringRef filePath) {
  mlir::MLIRContext *context = module.getContext();

  // Step 1: Convert MLIR dialects to the LLVM dialect
  mlir::LLVMConversionTarget conversionTarget(*context);
  conversionTarget.addLegalDialect<mlir::LLVM::LLVMDialect>();
  conversionTarget.addLegalOp<mlir::ModuleOp>();

  mlir::LLVMTypeConverter typeConverter(context);

  mlir::RewritePatternSet patterns(context);
  mlir::arith::populateArithToLLVMConversionPatterns(typeConverter, patterns);
  mlir::populateFuncToLLVMConversionPatterns(typeConverter, patterns);

  if (mlir::failed(mlir::applyFullConversion(module, conversionTarget,
                                             std::move(patterns)))) {
    return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                   "Failed to lower MLIR module to LLVM IR.");
  }

  // Step 2: Translate LLVM IR in MLIR to LLVM IR Module
  llvm::LLVMContext llvmContext;
  mlir::registerLLVMDialectTranslation(*context);
  mlir::registerBuiltinDialectTranslation(*module->getContext());
  auto llvmModule = mlir::translateModuleToLLVMIR(module, llvmContext);
  if (!llvmModule) {
    return llvm::createStringError(
        llvm::inconvertibleErrorCode(),
        "Failed to translate MLIR module to LLVM IR.");
  }

  // Step 3: Compile LLVM IR Module to native object code
  llvm::InitializeNativeTarget();
  llvm::InitializeNativeTargetAsmPrinter();

  const auto *targetTriple = LLVM_HOST_TRIPLE;
  std::string error;
  const auto *target = llvm::TargetRegistry::lookupTarget(targetTriple, error);
  if (!target) {
    return llvm::createStringError(llvm::inconvertibleErrorCode(), error);
  }

  llvm::TargetOptions opt;
  std::optional<llvm::Reloc::Model> relocModel = llvm::Reloc::Model::PIC_;
  auto *targetMachine = target->createTargetMachine(
      targetTriple, /* cpu */ "generic", /* features*/ "", opt, relocModel);

  llvmModule->setTargetTriple(targetTriple);
  llvmModule->setDataLayout(targetMachine->createDataLayout());

  llvmModule->dump();

  llvm::legacy::PassManager pm;

  llvm::Expected<llvm::sys::fs::TempFile> expectedFile =
      llvm::sys::fs::TempFile::create("main-%%%%%%.tmp.o");
  if (!expectedFile) {
    return expectedFile.takeError();
  }
  llvm::raw_fd_ostream dest(expectedFile->FD, /*shouldClose=*/false);
  if (targetMachine->addPassesToEmitFile(pm, dest, nullptr,
                                         llvm::CGFT_ObjectFile)) {
    return llvm::createStringError(
        llvm::inconvertibleErrorCode(),
        "The target machine can't emit a file of this type");
  }
  pm.run(*llvmModule);

  dest.flush();

  // Step 4: Use Clang C++ API to link the generated object code into an
  // executable
  llvm::IntrusiveRefCntPtr<clang::DiagnosticIDs> diagId(
      new clang::DiagnosticIDs());
  llvm::IntrusiveRefCntPtr<clang::DiagnosticOptions> diagOpts =
      new clang::DiagnosticOptions();
  clang::TextDiagnosticPrinter printer(llvm::errs(), &*diagOpts);
  clang::DiagnosticsEngine diags(diagId, &*diagOpts, &printer, false);

  clang::driver::Driver driver("clang", targetTriple, diags);

  llvm::SmallVector<const char *, 16> args;
  args.push_back("./bin/clang");
  args.push_back(expectedFile->TmpName.c_str());
  args.push_back("-o");
  args.push_back(filePath.data());

  std::unique_ptr<clang::driver::Compilation> compilation(
      driver.BuildCompilation(args));
  if (!compilation) {
    assert(!expectedFile->discard());
    return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                   "Failed to create Clang compilation");
  }

  // Perform linking by executing the jobs generated by the compilation
  llvm::SmallVector<std::pair<int, const clang::driver::Command *>>
      failingCommands;
  int result = driver.ExecuteCompilation(*compilation, failingCommands);

  assert(!expectedFile->discard());

  if (result != 0) {
    return llvm::createStringError(llvm::inconvertibleErrorCode(),
                                   "Failed to link object file");
  }
  return llvm::Error::success();
}
